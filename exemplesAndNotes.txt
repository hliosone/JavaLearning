import java.util.Arrays;
import java.util.StringTokenizer; //pour utiliser Str Builder/Buffer

import fr.sstelcher.*;

public class App {
    public static void main(String[] args) {
      System.out.println("Hello world!");
      Player One = new Player("Stan");
      Player Two = new Player("Stan");
      Player Three = new Player("Stan");
      Player Four = new Player("Stan");
      Four.displayName();

      int tab[] = new int[5];
      Arrays.fill(tab, 15);

      //String est immuable, en reaffectant une valeur on va en fait detruire l'ancienne et la
      // liberer de la memoire et en creer une nouvelle
      String test1 = "Test";
      String test2 = "reussi";
      String test3 = "Reussi";

      System.out.println(test1.concat(" ").concat(test2).concat(" !"));
      // concat est plus rapide que +

      //string.trim() va supprimer tous les espaces
      //.replace('carac ou string', 'carac' ou string) va remplacer toutes les appearances par la nouvelle

      System.out.println(test1.charAt(0));
      System.out.println(test1.substring(0, 3)); 
      //.substring(pos, pos exclue);

      System.out.println(test3.equals(test2));
      System.out.println(test3.compareTo(test2)); //compare les codes ascii et renvoie la difference en entier

      String s = "C/ProgramFiles/user/sst";
      StringTokenizer st = new StringTokenizer(s, "/"); // on peut rajouter true en argument pour recup
      // aussi les delimiteurs

      while (st.hasMoreTokens()){
        System.out.println(st.nextToken());
      }

      System.out.println("Taille est : "+ test3.length()); 

      StringBuilder newS = new StringBuilder(); //Cree une string avec des methodes particulieres qui seront possible
      //.capacity() pour la capacité sur une StringBuilder tandis que sur une string capacité = taille car new object
      // string n'est pas muable tandis que StringBuilder l'est
      //.append(blabla)
      //StringBuilder only mono thread

      StringBuffer newS2 = new StringBuffer(); // pour multi thread, thread safe
      //Pareil que StringBuilder pour les méthodes
      

      for (int el : tab){
        System.out.print(el + " ");
      }
      //tab.toString()
  }
}
  /*
\n : nouvelle ligne
\t : tabulation
\r : retour chariot
\b : retour arrière
\f : nouvelle page
\' \" (Protection)
   */

      InputStreamReader isr = new InputStreamReader(System.in); //atends un flux à lire
      BufferedReader br = new BufferedReader(isr); /*Va permettre de faire de la lecture de données
      est thread safe (synchrone)
      considere que toute saisie faite est une chaine de caractere (String)
      Buffer de 8192 caracteres
      Méthodes : 
      - read() : lire un caractere
      - readLine() : lire une chaine, peut lever une exception
      - skip(N) : ignore N caractères
      */

      Scanner sc = new Scanner(System.in); 
      /* Prend direct un inputStream en parametre
      plus lent et pas thread safe, est asynchrone
      lecture de donnees + parsing (verifications, controles, etc)
      Buffer de 1024 caracteres
      Méthodes :
      - nextLine()
      - nextChar()
      - nextInt()
      etc ...
      */
      System.out.print("Comment t'appelle tu ? ");
      String name = br.readLine();
      System.out.println(name);

      System.out.print("A quel niveau acceder ? ");
      int gameLevel = sc.nextInt();
      System.out.println(gameLevel);

      Scanner sc = new Scanner(System.in);
      try{
        System.out.print("A quel niveau voulez-vous acceder ? : ");
        int gameLevel = sc.nextInt();
        System.out.println(gameLevel);
      } catch(InputMismatchException e){
        System.out.println("Le niveau n'existe pas !");
        e.printStackTrace(); //nous affiche l'erreur en détails
        //System.out.println("Erreur : " + e.getMessage()); Pareil que au dessus normalement
        
      } // on peut enchainer les catchs, on met les plus potentiels en premier
      catch (Exception e){
        System.out.println("Il y a eu un probleme dans le jeu, redémarrez");
      } finally { //quoiquil arrive on continuera cette partie du programme
        System.out.println("Ok fin");
      }



      HERITAGE :


      //final veut dire que la classe sera non extendable
public final class DonjonGuardian extends Player

// Dans la classe mere
//protected permet l'accès aux variables pour les classes qui heritent de la classe
    //reste private sinon
    protected static int nbPlayer = 0;
    protected String name;

public DonjonGuardian(String name, String _medal){
super(name); //creer une instance avec le constructeur mere

//super va permettre ici d'utiliser la methode de la classe parente si la meme existe dans notre classe
public void displayTestS(){
        super.displayTest();
    }

//on peut aussi mettre super sur une methode si on veut quelle ne soit dupliquee et redefinie sur une classe enfant
// pareil sur un attribut de classe
//pareil sur un attribut dans une fonction
//final peut etre consideree comme une constante aussi
exemple sur la classe mere :

public final void move( blbla ){
    // si une methode move existe dans notre classe enfant elle ne pourra pas etre utilisee 
}


